# ğŸ“¦ Four Pillars of Object-Oriented Programming (OOP)

Ø¯Ø± Ø§ÛŒÙ† Ø±ÛŒÙ¾Ø§Ø²ÛŒØªÙˆØ±ÛŒ Ù‚ØµØ¯ Ø¯Ø§Ø±ÛŒÙ… Ø¨Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø§Ø±Ø§Ø¯Ø§ÛŒÙ… Ø´ÛŒâ€ŒÚ¯Ø±Ø§ (Object-Oriented Programming) Ùˆ Ú†Ù‡Ø§Ø± Ø³ØªÙˆÙ† Ø§ØµÙ„ÛŒ Ø¢Ù† Ø¨Ù¾Ø±Ø¯Ø§Ø²ÛŒÙ….


---

## ğŸ”‘ Ú†Ù‡Ø§Ø± Ø³ØªÙˆÙ† Ø§ØµÙ„ÛŒ OOP

1. **Inheritance** (ÙˆØ±Ø§Ø«Øª)
2. **Polymorphism** (Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ)
3. **Encapsulation** (Ú©Ù¾Ø³ÙˆÙ„Ù‡â€ŒØ³Ø§Ø²ÛŒ)
4. **Abstraction** (Ø§Ù†ØªØ²Ø§Ø¹)

---

## ğŸ§¬ ÙˆØ±Ø§Ø«Øª (Inheritance)

ÙˆØ±Ø§Ø«Øª ÛŒÚ©ÛŒ Ø§Ø² Ù¾Ø§ÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù… OOP Ø§Ø³Øª Ú©Ù‡ Ø¨Ù‡ ÛŒÚ© Ú©Ù„Ø§Ø³ Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ø®ØµÙˆØµÛŒØ§Øª Ùˆ Ø±ÙØªØ§Ø±Ù‡Ø§ÛŒ ÛŒÚ© Ú©Ù„Ø§Ø³ Ø¯ÛŒÚ¯Ø± Ø±Ø§ Ø¨Ù‡ Ø§Ø±Ø« Ø¨Ø¨Ø±Ø¯.
Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ù‡ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø®ØªÙ„Ù ÙˆØ±Ø§Ø«Øª Ù…ÛŒâ€ŒÙ¾Ø±Ø¯Ø§Ø²ÛŒÙ…:



### 1. Single Inheritance

Ú©Ù„Ø§Ø³ ÙØ±Ø²Ù†Ø¯ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø§Ø² ÛŒÚ© Ú©Ù„Ø§Ø³ ÙˆØ§Ù„Ø¯ Ø§Ø±Ø« Ù…ÛŒâ€ŒØ¨Ø±Ø¯. Ø¯Ø± ÙˆØ±Ø§Ø«Øª ØªÚ©ÛŒØŒ Ú©Ù„Ø§Ø³ ÙØ±Ø²Ù†Ø¯ ÛŒÚ© Ø±Ø§Ø¨Ø·Ù‡ Ø³Ø§Ø¯Ù‡ Ùˆ Ù…Ø³ØªÙ‚ÛŒÙ… Ø¨Ø§ Ú©Ù„Ø§Ø³ ÙˆØ§Ù„Ø¯ Ø¯Ø§Ø±Ø¯. Ø§ÛŒÙ† Ù…Ø¯Ù„ Ø³Ø±Ø¹Øª Ø¯Ø±Ú© Ùˆ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ú©Ø¯ Ø±Ø§ Ø§ÙØ²Ø§ÛŒØ´ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ùˆ Ø¨Ø±Ø§ÛŒ Ù…ÙˆØ§Ù‚Ø¹ÛŒ Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³Øª Ú©Ù‡ Ø±Ø§Ø¨Ø·Ù‡ "ÛŒÚ© Ø¨Ù‡ ÛŒÚ©" Ø¨ÛŒÙ† Ø¯Ùˆ Ù…ÙÙ‡ÙˆÙ… Ø¨Ø±Ù‚Ø±Ø§Ø± Ø¨Ø§Ø´Ø¯ØŒ Ù…Ø«Ù„Ø§Ù‹ `Cat` Ùˆ `Animal`. ÛŒÚ©ÛŒ Ø§Ø² Ù…Ø²Ø§ÛŒØ§ÛŒ Ø¢Ù† Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªÚ©Ø±Ø§Ø± Ú©Ø¯ Ø§Ø³ØªØŒ ÙˆÙ„ÛŒ ØªÙˆØ¬Ù‡ Ú©Ù†ÛŒØ¯ Ú©Ù‡ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒ Ø´Ø¯ÛŒØ¯ Ø¨Ù‡ Ú©Ù„Ø§Ø³ ÙˆØ§Ù„Ø¯ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø§Ù†Ø¹Ø·Ø§Ùâ€ŒÙ¾Ø°ÛŒØ±ÛŒ Ø±Ø§ Ú©Ø§Ù‡Ø´ Ø¯Ù‡Ø¯.

```csharp
public class Animal
{
    public void Eat() => Console.WriteLine("The animal is eating");
}

public class Cat : Animal
{
    public void Speak() => Console.WriteLine("MEOW");
}

class Program
{
    static void Main()
    {
        var myCat = new Cat();
        
        myCat.Eat();   // Inherited from Animal (base class)
        myCat.Speak(); // Defined in Cat (derived class)
    }
}
```





### 2. Multilevel Inheritance

Ø²Ù†Ø¬ÛŒØ±Ù‡â€ŒØ§ÛŒ Ø§Ø² Ø§Ø±Ø«â€ŒØ¨Ø±ÛŒ Ø¨ÛŒÙ† Ú†Ù†Ø¯ Ú©Ù„Ø§Ø³ Ø´Ú©Ù„ Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯. Ø¯Ø± ÙˆØ±Ø§Ø«Øª Ú†Ù†Ø¯Ø³Ø·Ø­ÛŒØŒ Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ Ø¨Ù‡ Ø´Ú©Ù„ Ø³Ù„Ø³Ù„Ù‡ Ù…Ø±Ø§ØªØ¨ÛŒ Ø³Ø§Ø²Ù…Ø§Ù†Ø¯Ù‡ÛŒ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ Ùˆ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ Ø§Ø² Ú†Ù†Ø¯ Ù†Ø³Ù„ Ù…Ù†ØªÙ‚Ù„ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯. Ø§ÛŒÙ† ØªÚ©Ù†ÛŒÚ© Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ù†Ù…Ø§ÛŒÛŒ Ø³Ù„Ø³Ù„Ù‡â€ŒÙ…Ø±Ø§ØªØ¨â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ Ù…Ø§Ù†Ù†Ø¯ "Ù…ÙˆØ¬ÙˆØ¯Ø§Øª -> Ø­ÛŒÙˆØ§Ù†Ø§Øª -> Ú¯Ø±Ø¨Ù‡" Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³Øª. Ø¨Ø§ Ø§ÛŒÙ† Ø­Ø§Ù„ØŒ Ø§ÙØ²Ø§ÛŒØ´ Ø¹Ù…Ù‚ Ø²Ù†Ø¬ÛŒØ±Ù‡ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù¾ÛŒÚ†ÛŒØ¯Ú¯ÛŒ Ø±Ø§ Ø¨Ø§Ù„Ø§ Ø¨Ø¨Ø±Ø¯ Ùˆ Ø§Ø´Ú©Ø§Ù„â€ŒØ²Ø¯Ø§ÛŒÛŒ Ø±Ø§ Ø¯Ø´ÙˆØ§Ø± Ú©Ù†Ø¯.


```csharp
//this is our level 1 (base) class
public class Creature  
{   
   public void Breath() => Console.WriteLine("the Creature is breating");
}
//Animal is the level 2
public class Animal : Creature
{
   public void Eat() => Console.WriteLine("the Animal is eating");
}
//and the level 3 so our chain would look like Cat -> Animal -> Creature
public class Cat : Animal
{
   public void Speak() => Console.WriteLine("the Cat says Meow");
}

var myCat = new Cat();
//the Breath method is inherited from the grandparent class (Creature)
myCat.Breath();
//the Eat method is inherited from the parent class (Animal)
myCat.Eat();
//the Speak is defined inside the Cat class itself
myCat.Speak();
```



### 3. Hierarchical Inheritance

Ú†Ù†Ø¯ÛŒÙ† Ú©Ù„Ø§Ø³ ÙØ±Ø²Ù†Ø¯ Ø§Ø² ÛŒÚ© Ú©Ù„Ø§Ø³ ÙˆØ§Ù„Ø¯ Ù…Ø´ØªØ±Ú© Ø§Ø±Ø« Ù…ÛŒâ€ŒØ¨Ø±Ù†Ø¯. Ø¯Ø± ÙˆØ±Ø§Ø«Øª Ø³Ù„Ø³Ù„Ù‡â€ŒÙ…Ø±Ø§ØªØ¨ÛŒØŒ ÛŒÚ© Ø³ÙˆÙ¾Ø±ÙƒÙ„Ø§Ø³ Ù…Ø´ØªØ±Ú©ØŒ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ Ùˆ Ù…ØªØ¯Ù‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡ Ø±Ø§ Ø§Ø±Ø§Ø¦Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ùˆ Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ÛŒ Ù…ØªØ¹Ø¯Ø¯ÛŒ Ø§Ø² Ø¢Ù† Ø§Ø±Ø« Ù…ÛŒâ€ŒØ¨Ø±Ù†Ø¯. Ø§ÛŒÙ† Ø³Ø§Ø®ØªØ§Ø± Ø¨Ù‡ Ù…Ø§ Ø§Ù…Ú©Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ ØªØ§ Ú©Ø¯Ù‡Ø§ÛŒ Ù…Ø´ØªØ±Ú© Ø±Ø§ ÛŒÚ©Ø¨Ø§Ø± ØªØ¹Ø±ÛŒÙ Ú©Ù†ÛŒÙ… Ùˆ Ø§Ø² Ø¢Ù† Ø¯Ø± Ú†Ù†Ø¯ÛŒÙ† Ø²ÛŒØ±Ú©Ù„Ø§Ø³ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ…. ØªÙˆØ¬Ù‡ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒØ¯ Ú©Ù‡ Ø§Ú¯Ø± Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø±ÙØªØ§Ø±Ù‡Ø§ÛŒ Ø¨Ø³ÛŒØ§Ø± Ù…ØªÙØ§ÙˆØª Ø¨Ø§Ø´Ø¯ØŒ Ø§ÛŒÙ† Ø§Ù„Ú¯Ùˆ Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø¨Ù‡ Ø³Ø®ØªÛŒ Ù‚Ø§Ø¨Ù„ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ø´ÙˆØ¯.

```csharp
//this is our base class(superclass)
public class Electronics
{
    public void TurnOn() => Console.WriteLine("the electronic is turning on");
}
//Phone and Laptop classes are subclasses derived from our superclass
public class Phone : Electronics
{
    public void Calling() => Console.WriteLine("the phone is calling");
}

public class Laptop : Electronics
{
    public void Computing() => Console.WriteLine("the laptop is computing");
}

new Phone().Calling();
new Laptop().Computing();
```


### 4. Multiple Inheritance

ÛŒÚ© Ú©Ù„Ø§Ø³ Ø§Ø² Ú†Ù†Ø¯ÛŒÙ† Ú©Ù„Ø§Ø³ ÙˆØ§Ù„Ø¯ Ø§Ø±Ø« Ù…ÛŒâ€ŒØ¨Ø±Ø¯. ÙˆØ±Ø§Ø«Øª Ú†Ù†Ø¯Ú¯Ø§Ù†Ù‡ Ø§Ù…Ú©Ø§Ù† ØªØ±Ú©ÛŒØ¨ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ Ùˆ Ø±ÙØªØ§Ø±Ù‡Ø§ÛŒ Ú†Ù†Ø¯ Ú©Ù„Ø§Ø³ (ÛŒØ§ Ø§ÛŒÙ†ØªØ±ÙÛŒØ³) Ø±Ø§ Ø¯Ø± ÛŒÚ© Ú©Ù„Ø§Ø³ ÙˆØ§Ø­Ø¯ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯. Ø§ÛŒÙ†Ú©Ø§Ø± Ø§Ù†Ø¹Ø·Ø§Ùâ€ŒÙ¾Ø°ÛŒØ±ÛŒ Ø²ÛŒØ§Ø¯ÛŒ Ù…ÛŒâ€ŒØ¢ÙˆØ±Ø¯ØŒ Ø§Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù…Ù†Ø¬Ø± Ø¨Ù‡ "Ù…Ø´Ú©Ù„ Ø§Ù„Ù…Ø§Ø³" (Diamond Problem) Ø´ÙˆØ¯ØŒ Ø¬Ø§ÛŒÛŒ Ú©Ù‡ ØªØ¯Ø§Ø®Ù„ÛŒ Ø¯Ø± ØªÙˆØ§Ø±Ø« ØµÙØ§Øª Ø§Ø² Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ø±Ø® Ù…ÛŒâ€ŒØ¯Ù‡Ø¯. Ø¯Ø± Ø²Ø¨Ø§Ù†â€ŒÙ‡Ø§ÛŒÛŒ Ù…Ø§Ù†Ù†Ø¯ C# Ø¨Ø±Ø§ÛŒ Ø­Ù„ Ø§ÛŒÙ† Ù…ÙˆØ¶ÙˆØ¹ Ø§Ø² Ø§ÛŒÙ†ØªØ±ÙÛŒØ³â€ŒÙ‡Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.

```csharp
public interface ICall {void Calling();}
public interface IPhoto {void TakingPhoto();}
public interface IFlash {void FlashLight();}

public class Phone : ICall, IPhoto, IFlash
{
    public void Calling() => Console.WriteLine("phone is calling");
    public void TakingPhoto() => Console.WriteLine("phone is taking a photo");
    public void FlashLight() => Console.WriteLine("phone's FlashLight is turned on");
}

new Phone().Calling();
new Phone().TakingPhoto();
new Phone().FlashLight();
```



### 5. Hybrid Inheritance

ØªØ±Ú©ÛŒØ¨ÛŒ Ø§Ø² Ú†Ù†Ø¯ Ù†ÙˆØ¹ ÙˆØ±Ø§Ø«Øª Ø¨Ø§Ù„Ø§. ÙˆØ±Ø§Ø«Øª ØªØ±Ú©ÛŒØ¨ÛŒ ÛŒØ§ HybridØŒ ØªØ±Ú©ÛŒØ¨ÛŒ Ø§Ø² Ú†Ù†Ø¯ Ù†ÙˆØ¹ ÙˆØ±Ø§Ø«Øª (Ù…Ø§Ù†Ù†Ø¯ ØªÚ©ØŒ Ú†Ù†Ø¯Ø³Ø·Ø­ÛŒ Ùˆ Ú†Ù†Ø¯Ú¯Ø§Ù†Ù‡) Ø§Ø³Øª ØªØ§ Ø§Ù†Ø¹Ø·Ø§Ù Ùˆ Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ±ÛŒ Ø§Ø±Ø§Ø¦Ù‡ Ø¯Ù‡Ø¯. Ø§ÛŒÙ† Ø§Ù„Ú¯Ùˆ Ø¯Ø± Ø·Ø±Ø§Ø­ÛŒ Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒÚ†ÛŒØ¯Ù‡ Ø¨Ø³ÛŒØ§Ø± Ú©Ø§Ø±Ø¢Ù…Ø¯ Ø§Ø³Øª Ø§Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ùˆ Ø¯Ø±Ú© Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø±Ø§ Ø¯Ø´ÙˆØ§Ø± Ø³Ø§Ø²Ø¯.

```csharp
public class Device
{
    public string Model{get;set;}
}

public interface ICamera
{
    void Photo();
}
public interface ICall
{
    void Calling();
}
public class Phone : Device, ICamera, ICall
{
    public void Photo() => Console.WriteLine($"{Model} is taking photo");   
    public void Calling() => Console.WriteLine($"{Model} is making a call");
}

public class Camera :Device, ICamera
{
    public void Photo() => Console.WriteLine($"{Model} is taking photo");
}

var myPhone = new Phone{Model = "Galaxy s24"};
myPhone.Photo();
myPhone.Calling();


var myCamera = new Camera{Model = "myRandomCamera"};
myCamera.Photo();
```

---


### Beyond the Basics



---

## ğŸ­ Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ (Polymorphism)

Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ù…Ø¹Ù†Ø§Ø³Øª Ú©Ù‡ ÛŒÚ© ØªØ§Ø¨Ø¹ ÛŒØ§ Ø´ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø±ÙØªØ§Ø±Ù‡Ø§ÛŒ Ù…ØªÙØ§ÙˆØªÛŒ Ø¯Ø± Ø´Ø±Ø§ÛŒØ· Ù…Ø®ØªÙ„Ù Ø§Ø² Ø®ÙˆØ¯ Ù†Ø´Ø§Ù† Ø¯Ù‡Ø¯.
Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ù‡ **Ú†Ù‡Ø§Ø± Ù†ÙˆØ¹ Ø§ØµÙ„ÛŒ Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ** Ù…ÛŒâ€ŒÙ¾Ø±Ø¯Ø§Ø²ÛŒÙ…:
### 1. Ad-hoc Polymorphism (Static Polymorphism) 

Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ Ø¢Ø¯Ù‡ÙˆÚ© (Ad-hoc Polymorphism) Ø¨Ù‡ Ø­Ø§Ù„ØªÛŒ Ø§Ø² Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ Ù…ÛŒâ€ŒÚ¯ÙˆÛŒÙ†Ø¯ Ú©Ù‡ Ø¯Ø± Ø¢Ù† ÛŒÚ© Ù†Ø§Ù… Ø¨Ø±Ø§ÛŒ ØªØ§Ø¨Ø¹ ÛŒØ§ Ø¹Ù…Ù„Ú¯Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ØªÙØ§ÙˆØªÛŒ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯ Ùˆ Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„Ø± Ø¯Ø± Ø²Ù…Ø§Ù† Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹ Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù†â€ŒÙ‡Ø§ØŒ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ù†Ø§Ø³Ø¨ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
```csharp
public class Arithmetic
{
    // Method overloading   
    public int Add(int a, int b)
    {
        return a + b;
    }
    public double Add(double a, double b)
    {
        return a + b;
    }
   
}
```
### 2. Parametric Polymorphism (Generic)

Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±ÛŒÚ© (Parametric Polymorphism) Ø¨Ù‡ Ø­Ø§Ù„ØªÛŒ Ø§Ø² Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ Ú¯ÙØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ú©Ù‡ Ø¯Ø± Ø¢Ù† ÛŒÚ© ØªØ§Ø¨Ø¹ ÛŒØ§ Ø³Ø§Ø®ØªØ§Ø± Ø¯Ø§Ø¯Ù‡ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ù†ÙˆØ¹ (type parameters) Ø¨Ù‡â€ŒØµÙˆØ±Øª Ø¹Ù…ÙˆÙ…ÛŒ ØªØ¹Ø±ÛŒÙ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ø¯Ø± Ø²Ù…Ø§Ù† Ø§Ø³ØªÙØ§Ø¯Ù‡ (Instantiation) Ø¨Ø§ Ø§Ù†ÙˆØ§Ø¹ Ø®Ø§Øµ Ù¾Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯Ø› Ø¨Ù‡ Ø§ÛŒÙ† ØªØ±ØªÛŒØ¨ Ù‡Ù…Ø§Ù† Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø±ÙˆÛŒ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø®ØªÙ„Ù Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ø¨Ø¯ÙˆÙ† Ø¢Ù†â€ŒÚ©Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù†ÙˆØ¹ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡â€ŒØ§ÛŒ Ú©Ø¯ ØªÚ©Ø±Ø§Ø±ÛŒ Ø¨Ù†ÙˆÛŒØ³ÛŒÙ….
```csharp
public class Box<T>
{
    public T Value;
}

//here we define our type for the new instance of the Box and we define value
var randomBox = new Box<string>{Value = "random data"};

Console.WriteLine(randomBox.Value);


public class ListBox<T>
{
    public List<T> Items = new List<T>();
}

var randomListBox = new ListBox<string>{Items = {"random data", "more random data"}};
foreach (var item in randomListBox.Items)
{    
    Console.WriteLine(item);
}
```
### 3. Subtype (Inclusion) Polymorphism

Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ Ø²ÛŒØ±Ù†ÙˆØ¹ (Subtype Polymorphism) Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ ØªØ§ Ø§Ø±Ø¬Ø§Ø¹ ÛŒØ§ Ø§Ø´Ø§Ø±Ù‡â€ŒÚ¯Ø±ÛŒ Ø¨Ù‡ ÛŒÚ© Ú©Ù„Ø§Ø³ Ù¾Ø§ÛŒÙ‡ØŒ Ø¨Ù‡ Ø§Ø´ÛŒØ§ÛŒ Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ÛŒ Ù…Ø´ØªÙ‚â€ŒØ´Ø¯Ù‡ Ø§Ø´Ø§Ø±Ù‡ Ú©Ù†Ø¯ Ùˆ Ù…ØªØ¯ Ù…Ù†Ø§Ø³Ø¨ Ø¯Ø± Ø²Ù…Ø§Ù† Ø§Ø¬Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ø´ÙˆØ¯. Ø§ÛŒÙ† Ø´ÛŒÙˆÙ‡ Ø¨Ø± Ù…Ø¨Ù†Ø§ÛŒ Ø§Ø±Ø«â€ŒØ¨Ø±ÛŒ (inheritance) Ùˆ Ù¾ÛŒÙˆÙ†Ø¯ Ø¯ÛŒØ±Ù‡Ù†Ú¯Ø§Ù… (late binding) Ø§Ø³Øª Ùˆ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…ØªØ¯Ù‡Ø§ÛŒ Ù…Ø¬Ø§Ø²ÛŒ (virtual methods) Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯.
```csharp
public class Shape
{
    public virtual void Draw() => Console.WriteLine("Drawing a shape");
}

public class Circle : Shape
{
    //we override the virtual method from base class
    public override void Draw() => Console.WriteLine("Drawing a Circle");
    
}

public class Triangle : Shape
{
    //This uses the virtual method from the base class
}
```
### 4. Coercion Polymorphism

Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ Ú©ÙˆØ¦Ø±ÛŒØ´Ù† (Coercion Polymorphism) Ø­Ø§Ù„ØªÛŒ Ø§Ø² Ú†Ù†Ø¯Ø±ÛŒØ®ØªÛŒ Ø§Ø³Øª Ú©Ù‡ Ø¯Ø± Ø¢Ù† Ø²Ø¨Ø§Ù† Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒÙ†ÙˆÛŒØ³ÛŒ Ø¨Ù‡â€ŒØ·ÙˆØ± Ø®ÙˆØ¯Ú©Ø§Ø± Ù†ÙˆØ¹ ÛŒÚ© Ù…Ù‚Ø¯Ø§Ø± Ø±Ø§ Ø¨Ù‡ Ù†ÙˆØ¹ Ø¯ÛŒÚ¯Ø±ÛŒ ØªØ¨Ø¯ÛŒÙ„ (cast) Ù…ÛŒâ€ŒÚ©Ù†Ø¯ ØªØ§ Ø¨ØªÙˆØ§Ù†Ø¯ Ø¢Ù† Ø±Ø§ Ø¯Ø± Ø²Ù…ÛŒÙ†Ù‡Ù” Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†Ø¯. Ø§ÛŒÙ† ØªØ¨Ø¯ÛŒÙ„ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¶Ù…Ù†ÛŒ (implicit) Ø¨Ø§Ø´Ø¯ØŒ Ø¨Ø¯ÙˆÙ† Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¯Ø®Ø§Ù„Øª Ù…Ø³ØªÙ‚ÛŒÙ… Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒÙ†ÙˆÛŒØ³ØŒ ÛŒØ§ ØµØ±ÛŒØ­ (explicit) Ùˆ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¹Ù…Ù„Ú¯Ø±Ù‡Ø§ÛŒ ØªØ¨Ø¯ÛŒÙ„ Ù†ÙˆØ¹.
```csharp
int a = 10;
double b = a;
//this is also known as Implicit type conversion

Console.WriteLine(b);


double x = 3.4;
int y = (int)x;
//this is Explicit type conversion

Console.WriteLine(y);

//both Implicit and Explicit type conversions are considered a form of polymorphism(Coercion)
```


---


### Beyond the Basics





#### -Strategy Design Pattern

Ø§Ù„Ú¯ÙˆÛŒ Ø·Ø±Ø§Ø­ÛŒ Strategy (Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ) ÛŒÚ©ÛŒ Ø§Ø² Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ø±ÙØªØ§Ø±ÛŒ Ø¯Ø± Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒÙ†ÙˆÛŒØ³ÛŒ Ø´ÛŒØ¡Ú¯Ø±Ø§ Ø§Ø³Øª Ú©Ù‡ Ø¨Ù‡ Ù…Ø§ Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ø±Ø§ Ø¯Ø± Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ø±Ø¯Ù‡ Ùˆ Ø¯Ø± Ø²Ù…Ø§Ù† Ø§Ø¬Ø±Ø§ØŒ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ø¯Ø± Ú©Ø¯ Ø§ØµÙ„ÛŒØŒ Ø¨ÛŒÙ† Ø¢Ù†â€ŒÙ‡Ø§ Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ø´ÙˆÛŒÙ….
Ø¯Ø± Ù…Ø«Ø§Ù„ Ø²ÛŒØ± Ù…Ø§ ÛŒÚ© Ø±Ø§Ø¨Ø· ISortStrategy ØªØ¹Ø±ÛŒÙ Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒÙ… Ú©Ù‡ Ù…ØªØ¯ÛŒ Ø¨Ù‡ Ù†Ø§Ù… Sort Ø¯Ø§Ø±Ø¯. Ø³Ù¾Ø³ ÛŒÚ© Ú©Ù„Ø§Ø³ BubbleSort Ø§ÛŒÙ† Ø±Ø§Ø¨Ø· Ø±Ø§ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ú©Ù„Ø§Ø³ Sorter Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø²Ù…ÛŒÙ†Ù‡ (Context) Ø¹Ù…Ù„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø³Ø§Ø²Ù†Ø¯Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ù…ÛŒâ€ŒÚ©Ù†Ø¯.



```csharp
public interface ISortStrategy {
    void Sort(List<int> data);
}

public class BubbleSort : ISortStrategy {
    //we implement the Sort method
    public void Sort(List<int> data) => Console.WriteLine("Sorted List");
}

public class Sorter {
    // we make a private field of type ISortStrategy
    private ISortStrategy _strategy;
    // we implement a constructor that accepts an argument of type ISortStrategy we store the argument in the earlier declared private field
    public Sorter(ISortStrategy strategy) => _strategy = strategy;
    // then when calling the method Execute we accept a list of ints and use the stored strategy from previous line to perform sorting 
    public void Execute(List<int> data) => _strategy.Sort(data);
}
```




#### -liskov substitution principle (LSP)







